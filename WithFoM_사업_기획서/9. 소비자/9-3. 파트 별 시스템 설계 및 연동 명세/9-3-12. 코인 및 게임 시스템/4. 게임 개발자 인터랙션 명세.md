<!-- WF:DOC=DEV -->
# 4: 게임 개발자 인터랙션 명세


## 4.1: API 명세 — 소비자 게임 참여


### 4.1.1: 파트너 게임 정보 조회 API

**엔드포인트**: `GET /api/v1/consumer/store/{storeId}/game`  
**인증**: Bearer Token (소비자 세션)

**응답 JSON**:

```json
{
  "exists": true,
  "game": {
    "gameId": "g_abc123",
    "type": "ROULETTE",
    "typeLabel": "룰렛",
    "slotCount": 6,
    "name": "럭키 룰렛",
    "status": "ACTIVE",
    "slotLayout": [
      { "slotIndex": 0, "rewardName": "10% 할인", "rank": 1, "depleted": false },
      { "slotIndex": 1, "rewardName": "꽝", "rank": null, "depleted": false },
      { "slotIndex": 2, "rewardName": "500P 적립", "rank": 2, "depleted": false },
      { "slotIndex": 3, "rewardName": "꽝", "rank": null, "depleted": false },
      { "slotIndex": 4, "rewardName": "아메리카노", "rank": 3, "depleted": true },
      { "slotIndex": 5, "rewardName": "꽝", "rank": null, "depleted": false }
    ]
  },
  "freePlay": {
    "available": true,
    "type": "PARTNER_PROVIDED",
    "remaining": 1
  },
  "coinBalance": {
    "fomCoin": 5,
    "partnerFomCoin": 2
  }
}
```

**응답 필드**:
- `exists`: 해당 매장 게임 존재 여부 (false 시 `game` 객체 null)
- `game.type`: ROULETTE | GACHA | SCRATCH | LADDER
- `game.slotCount`: 유형별 고정 슬롯 수 (룰렛 6 / 뽑기 12 / 스크래치 16 / 사다리 6)
- `game.status`: ACTIVE | PAUSED
- `game.slotLayout[]`: 슬롯별 시각 배치 정보 (4.3. 배분 알고리즘으로 생성)
- `game.slotLayout[].depleted`: 해당 리워드 소진 여부 (true 시 비활성 표시)
- `freePlay.available`: 무료 게임 기회 보유 여부
- `freePlay.type`: PARTNER_PROVIDED(파트너 제공) | FIRST_REGULAR(단골 첫 등록) | FRIEND_INVITE(친구 초대) | STAMP(스탬프 적립)
- `freePlay.remaining`: 잔여 무료 횟수
- `coinBalance`: 소비자 보유 코인 현황

**PAUSED 상태 시 응답**:

```json
{
  "exists": true,
  "game": {
    "gameId": "g_abc123",
    "type": "ROULETTE",
    "status": "PAUSED",
    "pauseMessage": "현재 리워드를 준비 중이에요."
  }
}
```


### 4.1.2: 파트너 게임 참여 (플레이) API

**엔드포인트**: `POST /api/v1/consumer/store/{storeId}/game/play`  
**인증**: Bearer Token (소비자 세션)

**요청 Body**:

```json
{
  "paymentType": "FOM_COIN",
  "selectedIndex": null
}
```

**요청 필드**:
- `paymentType`: FOM_COIN(폼 코인) | PARTNER_FOM_COIN(파트너 전용 폼 코인) | FREE(무료 기회)
- `selectedIndex`: 사다리 게임 전용 — 소비자가 선택한 시작점 인덱스(0~5). 다른 유형은 null

**처리 흐름**:
1. 게임 상태 검증 (ACTIVE 여부)
2. 결제 수단 검증 (코인 잔액 또는 무료 기회 확인)
3. 코인 차감 (FREE 시 무료 기회 차감)
4. 확률 엔진으로 결과 결정 (→ 4.2.)
5. 당첨 리워드 잔여 수량 감소
6. 슬롯 레이아웃 + 연출 데이터 생성 (→ 4.3., 4.4.)
7. 당첨 시 쿠폰 자동 발급
8. 응답 반환

**응답 JSON (룰렛/뽑기/사다리)**:

```json
{
  "played": true,
  "result": {
    "type": "WIN",
    "rewardId": "r_001",
    "rewardName": "10% 할인 쿠폰",
    "rewardType": "COUPON",
    "rank": 1,
    "guidanceMessage": "축하합니다! 1등 당첨!",
    "couponId": "cp_issued_001"
  },
  "gameData": {
    "gameType": "ROULETTE",
    "slotLayout": [
      { "slotIndex": 0, "label": "10% 할인", "rank": 1, "depleted": false },
      { "slotIndex": 1, "label": "꽝", "rank": null, "depleted": false },
      { "slotIndex": 2, "label": "500P", "rank": 2, "depleted": false },
      { "slotIndex": 3, "label": "꽝", "rank": null, "depleted": false },
      { "slotIndex": 4, "label": "사이즈업", "rank": 3, "depleted": true },
      { "slotIndex": 5, "label": "꽝", "rank": null, "depleted": false }
    ],
    "resultSlotIndex": 0,
    "animation": {
      "totalRotations": 5,
      "durationMs": 4000,
      "easing": "CUBIC_EASE_OUT"
    }
  },
  "coinBalance": {
    "fomCoin": 4,
    "partnerFomCoin": 2
  }
}
```

**응답 JSON (스크래치)**:

```json
{
  "played": true,
  "result": {
    "type": "WIN",
    "rewardId": "r_002",
    "rewardName": "500P 적립",
    "rewardType": "POINT",
    "rank": 2,
    "guidanceMessage": "축하합니다! 2등 당첨!",
    "couponId": "cp_issued_002"
  },
  "gameData": {
    "gameType": "SCRATCH",
    "grid": [
      [3, 1, 2, 4],
      [2, 3, 5, 1],
      [4, 5, 3, 6],
      [1, 6, 2, 5]
    ],
    "winningNumber": 3,
    "winningPositions": [[0,0], [1,1], [2,2]],
    "numberToReward": {
      "1": { "label": "10% 할인", "rank": 1 },
      "2": { "label": "500P", "rank": 2 },
      "3": { "label": "사이즈업", "rank": 3 },
      "4": { "label": "꽝", "rank": null },
      "5": { "label": "꽝", "rank": null },
      "6": { "label": "꽝", "rank": null }
    }
  }
}
```

**응답 JSON (사다리)**:

```json
{
  "played": true,
  "result": {
    "type": "WIN",
    "rewardId": "r_001",
    "rewardName": "10% 할인 쿠폰",
    "rewardType": "COUPON",
    "rank": 1,
    "guidanceMessage": "축하합니다! 1등 당첨!",
    "couponId": "cp_issued_001"
  },
  "gameData": {
    "gameType": "LADDER",
    "startIndex": 2,
    "endPoints": [
      { "index": 0, "label": "꽝" },
      { "index": 1, "label": "500P" },
      { "index": 2, "label": "10% 할인" },
      { "index": 3, "label": "꽝" },
      { "index": 4, "label": "사이즈업" },
      { "index": 5, "label": "꽝" }
    ],
    "resultEndIndex": 2,
    "rungs": [
      { "fromLine": 0, "toLine": 1, "yPosition": 0.15 },
      { "fromLine": 1, "toLine": 2, "yPosition": 0.30 },
      { "fromLine": 2, "toLine": 3, "yPosition": 0.20 },
      { "fromLine": 3, "toLine": 4, "yPosition": 0.50 },
      { "fromLine": 4, "toLine": 5, "yPosition": 0.40 },
      { "fromLine": 0, "toLine": 1, "yPosition": 0.65 },
      { "fromLine": 2, "toLine": 3, "yPosition": 0.75 },
      { "fromLine": 3, "toLine": 4, "yPosition": 0.85 }
    ],
    "path": [
      { "line": 2, "y": 0.0 },
      { "line": 2, "y": 0.30 },
      { "line": 1, "y": 0.30 },
      { "line": 1, "y": 0.65 },
      { "line": 0, "y": 0.65 },
      { "line": 0, "y": 1.0 }
    ],
    "animation": {
      "markerSpeedMs": 200,
      "pauseAtRungMs": 100
    }
  }
}
```

**꽝 결과 응답**:

```json
{
  "played": true,
  "result": {
    "type": "BLANK",
    "rewardId": null,
    "rewardName": null,
    "rank": null,
    "guidanceMessage": "다음 기회에!",
    "couponId": null
  },
  "gameData": { "..." : "유형별 gameData 동일 구조" },
  "coinBalance": { "fomCoin": 4, "partnerFomCoin": 2 }
}
```


### 4.1.3: 광고주 캠페인 게임 참여 API

**엔드포인트**: `POST /api/v1/consumer/campaign-game/{campaignId}/play`  
**인증**: Bearer Token (소비자 세션)

**요청 Body**:

```json
{
  "qrCode": "QR_CAMPAIGN_001_STORE_ABC",
  "selectedIndex": null
}
```

**요청 필드**:
- `qrCode`: 컵홀더 QR 스캔 값 (캠페인·매장 식별)
- `selectedIndex`: 사다리 게임 전용 시작점 인덱스

**처리 흐름**:
1. QR 코드에서 캠페인 ID·매장 ID 추출
2. 캠페인 유효성 검증 (기간·상태)
3. 코인 차감 없음 (무료)
4. 1~7등 확률 기반 결과 결정
5. 7등 당첨 + 파트너 참여 ON 시 → 서브 추첨 (4.2.3.)
6. 당첨 리워드(광고주 또는 파트너) 쿠폰 자동 발급
7. 응답 반환

**응답 JSON**:

```json
{
  "played": true,
  "campaign": {
    "campaignId": "c_001",
    "campaignName": "신제품 런칭 이벤트",
    "advertiserName": "ABC 브랜드"
  },
  "result": {
    "type": "WIN",
    "rank": 3,
    "source": "ADVERTISER",
    "rewardId": "adv_r_003",
    "rewardName": "ABC 브랜드 10% 할인",
    "rewardType": "COUPON",
    "guidanceMessage": "3등 당첨! ABC 브랜드 할인 쿠폰을 받으세요!",
    "couponId": "cp_adv_003"
  },
  "gameData": { "..." : "유형별 gameData 동일 구조" }
}
```

**7등 파트너 리워드 당첨 시**:

```json
{
  "result": {
    "type": "WIN",
    "rank": 7,
    "source": "PARTNER",
    "rewardId": "ptr_r_001",
    "rewardName": "매장 500원 할인 쿠폰",
    "rewardType": "COUPON",
    "guidanceMessage": "7등 당첨! 매장 쿠폰을 받으세요!",
    "couponId": "cp_ptr_001"
  }
}
```

**7등 파트너 참여 OFF 시**:

```json
{
  "result": {
    "type": "WIN",
    "rank": 7,
    "source": "ADVERTISER_FALLBACK",
    "rewardId": "adv_fallback_001",
    "rewardName": "ABC 브랜드 스티커",
    "guidanceMessage": "7등 당첨! 감사 선물을 드려요!"
  }
}
```


### 4.1.4: 무료 게임 기회 조회 API

**엔드포인트**: `GET /api/v1/consumer/store/{storeId}/game/free-play`  
**인증**: Bearer Token (소비자 세션)

**응답 JSON**:

```json
{
  "freePlayOpportunities": [
    {
      "type": "PARTNER_PROVIDED",
      "available": true,
      "remaining": 1,
      "dailyLimit": 1,
      "usedToday": 0,
      "targetGroup": "ALL"
    },
    {
      "type": "FIRST_REGULAR",
      "available": false,
      "remaining": 0,
      "reason": "ALREADY_USED"
    },
    {
      "type": "FRIEND_INVITE",
      "available": true,
      "remaining": 2
    },
    {
      "type": "STAMP",
      "available": true,
      "remaining": 1
    }
  ],
  "totalFreeRemaining": 4
}
```

**무료 기회 유형**:
- `PARTNER_PROVIDED`: 파트너 코인 적립 제공 (1인 하루 1회 제한, 대상 고객 한정)
- `FIRST_REGULAR`: 단골 스토어 첫 등록 (최초 1회)
- `FRIEND_INVITE`: 친구 초대 성공 (초대자·피초대자 각 1회)
- `STAMP`: 스탬프 1개 적립 시 (적립 건당 1회)


---


## 4.2: 서버 확률 엔진


### 4.2.1: 가중 랜덤 선택 알고리즘

모든 게임 유형에 공통 적용. 클라이언트 연출과 무관하게 서버에서 결과를 먼저 결정.

**입력**:
- `rewards[]`: 활성 리워드 목록 (remainingQuantity > 0인 항목만)
- `blank`: 꽝 설정 (enabled, probability)

**알고리즘 (의사코드)**:

```
function determineResult(rewards, blank):
    // 1. 활성 후보 구성
    candidates = []
    for reward in rewards:
        if reward.remainingQuantity > 0:
            candidates.add({ item: reward, originalProb: reward.probability })
    if blank.enabled:
        candidates.add({ item: BLANK, originalProb: blank.probability })

    // 2. 확률 정규화 (소진 리워드 제외로 합계 < 100% 가능)
    totalOriginalProb = sum(c.originalProb for c in candidates)
    for c in candidates:
        c.normalizedProb = (c.originalProb / totalOriginalProb) * 100

    // 3. 가중 랜덤 선택
    random = secureRandom(0, 99.999999)  // 암호학적 안전 난수
    cumulative = 0
    for c in candidates:
        cumulative += c.normalizedProb
        if random < cumulative:
            return c.item

    // 4. 부동소수점 보정 (fallback)
    return candidates.last().item
```

**필수 요건**:
- 암호학적 안전 난수 생성기(CSPRNG) 사용 — 예측·조작 방지
- 부동소수점 누적 오차 대비 마지막 후보 fallback 처리
- 트랜잭션 내에서 결과 결정 + 수량 감소 원자적 처리


### 4.2.2: 수량 소진 리워드 제외 및 확률 재분배

**처리 흐름**:

```
function getActiveCandidates(rewards, blank):
    active = rewards.filter(r => r.remainingQuantity > 0)
    
    if active.isEmpty() and blank.enabled:
        // 모든 리워드 소진, 꽝만 남음 → 게임 일시정지 트리거
        triggerGamePause()
        return ERROR("ALL_REWARDS_DEPLETED")
    
    if active.isEmpty() and !blank.enabled:
        triggerGamePause()
        return ERROR("ALL_REWARDS_DEPLETED")
    
    // 확률 비례 재분배
    originalSum = sum(r.probability for r in active)
    if blank.enabled:
        originalSum += blank.probability
    
    for r in active:
        r.effectiveProb = (r.probability / originalSum) * 100
    if blank.enabled:
        blank.effectiveProb = (blank.probability / originalSum) * 100
    
    return { active, blank }
```

**재분배 예시**:
- 원래 구성: A=30%, B=20%, C=20%, 꽝=30%
- B 소진 시: A=30/(30+20+30)×100=37.5%, C=25%, 꽝=37.5%
- 원래 비율 유지하며 100%로 재정규화


### 4.2.3: 광고주 게임 7등 서브 추첨

**처리 흐름**:

```
function handleRank7(partnerParticipation, partnerRewardPool):
    if !partnerParticipation.enabled:
        return advertiserFallbackReward  // 광고주 예비 7등 리워드
    
    if partnerRewardPool.isEmpty():
        return advertiserFallbackReward
    
    // 파트너 리워드 풀 내 가중 랜덤 선택 (꽝 없음, 100% 당첨)
    return weightedRandom(partnerRewardPool)
```

**유의사항**:
- 파트너 7등 리워드 풀은 수량 개념 없음 (확률만 적용)
- 파트너 참여 토글 OFF 시에도 리워드 풀 데이터 유지
- 서브 추첨은 메인 게임 결과(7등) 확정 후 별도 실행


---


## 4.3: 슬롯-리워드 배분 알고리즘

게임 UI에 표시할 슬롯에 리워드를 배분하는 시각적 매핑. 실제 당첨은 4.2. 확률 엔진이 결정하며, 슬롯 배분은 연출용.


### 4.3.1: 유형별 고정 슬롯 수

| 게임 유형 | 슬롯 수 | 형태 |
|-----------|---------|------|
| 룰렛 | 6 | 원형 구간 |
| 뽑기 | 12 | 캡슐 |
| 스크래치 | 16 | 4×4 격자 (별도 번호 배치 로직 → 4.4.3.) |
| 사다리 | 6 | 도착점 |


### 4.3.2: 배분 알고리즘 (룰렛·뽑기·사다리)

스크래치는 번호 기반 별도 로직(4.4.3.) 적용. 룰렛·뽑기·사다리에 공통 적용.

**입력**:
- `items[]`: 리워드 목록 + 꽝 (각 항목의 probability 포함)
- `slotCount`: 유형별 고정 슬롯 수

**알고리즘 (의사코드)**:

```
function distributeSlots(items, slotCount):
    // 1. 각 항목에 최소 1개 슬롯 보장
    allocation = {}
    for item in items:
        allocation[item] = 1
    
    // 2. 여분 슬롯 계산
    remainingSlots = slotCount - items.length
    
    // 3. 여분 슬롯을 확률 높은 순으로 1개씩 추가 배정
    sortedItems = items.sortByProbabilityDesc()
    index = 0
    while remainingSlots > 0:
        allocation[sortedItems[index % sortedItems.length]] += 1
        index += 1
        remainingSlots -= 1
    
    // 4. 슬롯 배치 (인접 동일 항목 방지를 위해 분산 배치)
    slotLayout = spreadEvenly(allocation, slotCount)
    
    return slotLayout
```

**분산 배치 (spreadEvenly)**:

```
function spreadEvenly(allocation, slotCount):
    // 여러 슬롯을 가진 항목이 인접하지 않도록 균등 분산
    slots = array(slotCount, null)
    
    // 할당 수가 많은 항목부터 배치 (간격 최대화)
    sortedByAllocation = allocation.sortByValueDesc()
    for item, count in sortedByAllocation:
        interval = floor(slotCount / count)
        offset = findBestOffset(slots, count, interval)
        for i in 0..count-1:
            pos = (offset + i * interval) % slotCount
            while slots[pos] != null:
                pos = (pos + 1) % slotCount
            slots[pos] = item
    
    return slots
```

**배분 예시** (룰렛 6칸, 리워드 3개 + 꽝):
- 입력: A(30%), B(20%), C(20%), 꽝(30%)
- 최소 배정: A=1, B=1, C=1, 꽝=1 (4칸 사용)
- 여분 2칸: A(30%), 꽝(30%) 순으로 추가 → A=2, B=1, C=1, 꽝=2
- 분산 배치: [A, 꽝, B, A, 꽝, C]

**소진 리워드 슬롯 처리**:
- 소진된 리워드에도 슬롯 유지 (빈 칸 방지)
- 해당 슬롯에 비활성(회색) 처리 + "소진" 표시
- `depleted: true` 플래그로 클라이언트에 전달


---


## 4.4: 게임 유형별 서버 구현 명세


### 4.4.1: 룰렛

**서버 처리**:

```
function playRoulette(gameId, consumer):
    game = getGame(gameId)
    result = determineResult(game.rewards, game.blank)  // 4.2.1.
    
    slotLayout = distributeSlots(game.allItems, 6)  // 4.3.2.
    resultSlotIndex = findSlotForResult(slotLayout, result)
    
    // 연출 데이터 생성
    animation = {
        totalRotations: randomInt(4, 7),         // 4~7바퀴 회전
        durationMs: randomInt(3500, 5000),        // 3.5~5초
        easing: "CUBIC_EASE_OUT",                 // 점진 감속 곡선
        finalAngle: calculateAngle(resultSlotIndex, 6)  // 결과 칸 중앙 각도
    }
    
    return { result, slotLayout, resultSlotIndex, animation }
```

**각도 계산**:

```
function calculateAngle(slotIndex, slotCount):
    slotAngle = 360 / slotCount       // 60° per slot
    centerAngle = slotIndex * slotAngle + slotAngle / 2
    jitter = randomFloat(-5, 5)       // ±5° 자연스러운 편차
    return centerAngle + jitter
```


### 4.4.2: 뽑기 (가챠)

**서버 처리**:

```
function playGacha(gameId, consumer):
    game = getGame(gameId)
    result = determineResult(game.rewards, game.blank)  // 4.2.1.
    
    slotLayout = distributeSlots(game.allItems, 12)  // 4.3.2.
    resultCapsuleIndex = findSlotForResult(slotLayout, result)
    
    // 캡슐 색상 매핑 (리워드별 고유 색상)
    capsuleColors = assignColors(game.allItems)
    
    animation = {
        shakePhases: 3,                           // 원통 흔들림 3단계
        shakeDurationMs: 2000,                    // 2초 흔들림
        ejectDurationMs: 1500,                    // 1.5초 사출
        openDurationMs: 800,                      // 0.8초 캡슐 열림
        resultCapsuleColor: capsuleColors[result]
    }
    
    return { result, slotLayout, resultCapsuleIndex, animation }
```

**캡슐 색상 할당**:
- 리워드별 고유 색상 (최대 6개 리워드 + 꽝 = 7색)
- 고정 팔레트: [빨강, 파랑, 초록, 노랑, 보라, 주황, 회색(꽝)]
- 소진 리워드 캡슐: 반투명 회색 처리


### 4.4.3: 스크래치

스크래치는 슬롯 배분 대신 **번호 배치 맵**을 서버에서 생성.

**서버 처리**:

```
function playScratch(gameId, consumer):
    game = getGame(gameId)
    result = determineResult(game.rewards, game.blank)  // 4.2.1.
    
    // 번호 할당: 리워드·꽝 각각에 고유 번호 부여
    numberMap = assignNumbers(game.allItems)  // { reward_A: 1, reward_B: 2, ..., blank: 6 }
    
    // 4×4 격자 번호 배치
    grid = generateGrid(result, numberMap)
    
    return { result, grid, numberMap }
```

**번호 배치 알고리즘**:

```
function generateGrid(result, numberMap):
    grid = array(4, 4, null)
    allNumbers = numberMap.values()
    
    if result.type == "WIN":
        winningNumber = numberMap[result.reward]
        
        // 1. 당첨 번호 3개를 무작위 위치에 배치
        winPositions = pickRandomPositions(grid, 3)
        for pos in winPositions:
            grid[pos.row][pos.col] = winningNumber
        
        // 2. 나머지 13칸에 다른 번호 배치
        otherNumbers = allNumbers.exclude(winningNumber)
        fillRemaining(grid, otherNumbers, maxPerNumber=2)
    
    else:  // BLANK
        // 모든 번호를 최대 2개까지만 배치 (3개 일치 불가 보장)
        fillAll(grid, allNumbers, maxPerNumber=2)
    
    return grid
```

**fillRemaining 상세**:

```
function fillRemaining(grid, numbers, maxPerNumber):
    usageCount = {}  // 각 번호 사용 횟수 추적
    emptyPositions = getEmptyPositions(grid)
    shuffle(emptyPositions)
    
    for pos in emptyPositions:
        availableNumbers = numbers.filter(n => usageCount[n] < maxPerNumber)
        if availableNumbers.isEmpty():
            // 모든 번호가 maxPerNumber 도달 → 새 번호 풀 확장
            resetUsageForLeastUsed(usageCount, maxPerNumber)
            availableNumbers = numbers.filter(n => usageCount[n] < maxPerNumber)
        
        selected = randomChoice(availableNumbers)
        grid[pos.row][pos.col] = selected
        usageCount[selected] = (usageCount[selected] || 0) + 1
    
    // 검증: 당첨 번호 외에 3개 이상 일치하는 번호가 없는지 확인
    validate(grid)
```

**검증 규칙**:
- WIN 시: 당첨 번호 정확히 3개, 다른 번호 각각 최대 2개
- BLANK 시: 모든 번호 각각 최대 2개 (3개 일치 불가 보장)
- 검증 실패 시 재생성 (최대 10회 시도, 이후 단순 배치 fallback)


### 4.4.4: 사다리

사다리는 소비자 시작점 선택 후 서버에서 결과 결정 + 사다리 구조 생성.

**서버 처리 흐름**:
1. 소비자가 시작점(0~5) 선택 → 서버에 전달
2. 확률 엔진으로 결과(리워드 또는 꽝) 결정
3. 결과에 해당하는 도착점 인덱스 결정
4. 선택된 시작점에서 결과 도착점까지 도달하는 사다리 구조 생성
5. 나머지 도착점에 다른 리워드/꽝 배정
6. 전체 사다리 구조 + 경로 데이터 클라이언트에 반환

**사다리 구조 생성 알고리즘**:

```
function generateLadder(startIndex, resultEndIndex, rewards, blank):
    LINE_COUNT = 6
    
    // 1. 도착점 배정 (결과 도착점 고정, 나머지 무작위)
    endPoints = array(LINE_COUNT, null)
    endPoints[resultEndIndex] = result
    remainingItems = distributeToEndPoints(rewards, blank, resultEndIndex)
    for i in 0..LINE_COUNT-1:
        if endPoints[i] == null:
            endPoints[i] = remainingItems.pop()
    
    // 2. 무작위 가로선(rung) 생성
    rungs = generateRandomRungs(LINE_COUNT)
    
    // 3. 경로 추적: 시작점 → 실제 도착점 확인
    actualEnd = tracePath(startIndex, rungs)
    
    // 4. 도착점 매칭 조정
    if actualEnd != resultEndIndex:
        // 도착점 라벨 스왑: 실제 도착점과 의도한 도착점의 내용 교환
        swap(endPoints[actualEnd], endPoints[resultEndIndex])
    
    // 5. 전체 경로 좌표 계산 (클라이언트 애니메이션용)
    path = calculateFullPath(startIndex, rungs)
    
    return { endPoints, rungs, path }
```

**가로선 생성 규칙**:

```
function generateRandomRungs(lineCount):
    rungs = []
    RUNG_COUNT = randomInt(6, 12)    // 적절한 복잡도
    MIN_Y_GAP = 0.08                 // 가로선 간 최소 간격 (전체 높이 대비)
    
    for i in 0..RUNG_COUNT-1:
        fromLine = randomInt(0, lineCount - 2)
        toLine = fromLine + 1        // 인접 라인만 연결
        yPosition = randomFloat(0.05, 0.95)
        
        // 같은 라인 쌍에 너무 가까운 가로선 방지
        if !hasNearbyRung(rungs, fromLine, toLine, yPosition, MIN_Y_GAP):
            rungs.add({ fromLine, toLine, yPosition })
    
    return rungs.sortByYPosition()
```

**경로 추적 알고리즘**:

```
function tracePath(startLine, rungs):
    currentLine = startLine
    path = [{ line: currentLine, y: 0.0 }]
    
    // 가로선을 y 위치 순으로 순회
    sortedRungs = rungs.sortByYPosition()
    
    for rung in sortedRungs:
        if rung.fromLine == currentLine:
            path.add({ line: currentLine, y: rung.yPosition })
            currentLine = rung.toLine
            path.add({ line: currentLine, y: rung.yPosition })
        elif rung.toLine == currentLine:
            path.add({ line: currentLine, y: rung.yPosition })
            currentLine = rung.fromLine
            path.add({ line: currentLine, y: rung.yPosition })
    
    path.add({ line: currentLine, y: 1.0 })
    return { endLine: currentLine, path: path }
```


---


## 4.5: 클라이언트 연출 명세


### 4.5.1: 공통 연출 규칙

| 항목 | 값 |
|------|-----|
| 게임 진입 전환 | 0.3초 페이드인 |
| 결과 확정 후 → 결과 화면 전환 | 0.5초 딜레이 + 0.3초 페이드 |
| 터치 피드백 | 햅틱 진동 (지원 기기) + 시각 하이라이트 |
| 사운드 | 게임별 효과음 (클라이언트 로컬 에셋) |
| 소진 슬롯 표시 | 회색 반투명(opacity 0.4) + "소진" 텍스트 오버레이 |


### 4.5.2: 룰렛 연출

| 단계 | 동작 | 시간 |
|------|------|------|
| 1. 대기 | 룰렛 디스크 정지, [회전] 버튼 활성 | — |
| 2. 회전 시작 | [회전] 클릭 → 디스크 고속 회전 시작 | 0ms |
| 3. 가속 | 최대 속도까지 선형 가속 | 0~500ms |
| 4. 등속 | 최대 속도 유지 (4~7바퀴) | 500~2500ms |
| 5. 감속 | `cubic-bezier(0.0, 0.0, 0.2, 1.0)` 이징 곡선으로 점진 감속 | 2500~4000ms |
| 6. 정지 | 서버 지정 결과 칸 중앙(±5°)에 포인터 정지 | 4000ms |
| 7. 결과 강조 | 당첨 칸 확대 + 깜빡임 2회 | 4000~4800ms |
| 8. 결과 전환 | 결과 화면으로 전환 | 5300ms |

**이징 함수**: `CUBIC_EASE_OUT` = `cubic-bezier(0.0, 0.0, 0.2, 1.0)`


### 4.5.3: 뽑기 연출

| 단계 | 동작 | 시간 |
|------|------|------|
| 1. 대기 | 원통 내 12개 캡슐 정적 표시, [스타트] 버튼 활성 | — |
| 2. 흔들림 | [스타트] 클릭 → 원통 좌우 흔들림 (캡슐 섞임 효과) 3단계 | 0~2000ms |
| 3. 사출 준비 | 흔들림 감소, 사출구 방향으로 캡슐 1개 이동 | 2000~2500ms |
| 4. 사출 | 결과 캡슐이 사출구에서 튀어나옴 (바운스 효과) | 2500~4000ms |
| 5. 캡슐 확대 | 사출된 캡슐이 화면 중앙으로 확대 이동 | 4000~4500ms |
| 6. 열림 | 캡슐 상하 분리 → 내부 리워드/꽝 표시 | 4500~5300ms |
| 7. 결과 전환 | 결과 화면으로 전환 | 5800ms |

**캡슐 물리 효과**: 흔들림 시 캡슐 간 충돌 시뮬레이션 (간소화된 2D 물리)


### 4.5.4: 스크래치 연출

| 단계 | 동작 | 시간 |
|------|------|------|
| 1. 대기 | 4×4 격자 코팅 커버 표시, "긁어서 확인하세요" 안내 | — |
| 2. 긁기 | 소비자 터치/드래그 → 코팅 점진 제거 (eraser 효과) | 사용자 속도 |
| 3. 번호 노출 | 코팅 제거된 칸에서 번호 점진 노출 | 실시간 |
| 4. 자동 당첨 | 같은 번호 3개 발견 시 → 나머지 칸 자동 오픈 (0.5초) + 당첨 이펙트 | 발견 시점+500ms |
| 5. 전체 오픈 | 모든 칸 긁은 경우 → 결과 판정 | 완료 시점 |
| 6. 결과 전환 | 결과 화면으로 전환 | +500ms |

**코팅 제거 기술**:
- Canvas 기반 eraser 마스크 (터치 반경 30px)
- 각 칸의 코팅 80% 이상 제거 시 번호 완전 노출로 자동 전환
- 같은 번호 3개 노출 감지는 클라이언트에서 실시간 체크

**자동 오픈 조건**:
- 3개 일치 번호 발견 시: 미오픈 칸 0.05초 간격 순차 오픈 → 당첨 연출
- 모든 칸 오픈 후 3개 일치 없음: 꽝 연출


### 4.5.5: 사다리 연출

| 단계 | 동작 | 시간 |
|------|------|------|
| 1. 시작점 선택 | 6개 시작점 표시, 소비자 1개 선택 | — |
| 2. 로딩 | "사다리 준비 중..." 표시 (서버 API 호출) | ~500ms |
| 3. 구조 표시 | 서버 응답 사다리 구조 렌더링 (가로선 + 도착점 라벨) | 500~800ms |
| 4. 마커 이동 | 선택 시작점에서 마커 자동 이동 시작 | 800ms~ |
| 5. 가로선 전환 | 가로선 만나면 방향 전환 (좌/우 이동) | 가로선당 200ms |
| 6. 세로 이동 | 세로 구간 이동 (가로선 사이) | 구간당 100~200ms |
| 7. 도착 | 도착점 도달 → 도착점 확대 + 강조 | 도착 시점 |
| 8. 결과 전환 | 결과 화면으로 전환 | +800ms |

**마커 이동 속도**: 서버에서 `path` 좌표 기반, 구간당 100~200ms


### 4.5.6: 결과 화면

**당첨 시**:

| 요소 | 내용 |
|------|------|
| 배경 | 축하 파티클 이펙트 (컨페티 + 별 반짝임) |
| 메인 텍스트 | "축하합니다!" (바운스 애니메이션) |
| 리워드 정보 | 리워드명 + 등수 + 안내 문구 (`guidanceMessage`) |
| CTA 버튼 | [쿠폰함에서 확인] → 마이페이지 > 쿠폰함 이동 |
| 보조 버튼 | [계속하기] → 게임 화면 복귀 |

**꽝 시**:

| 요소 | 내용 |
|------|------|
| 배경 | 부드러운 그라데이션 (위로 분위기) |
| 메인 텍스트 | 파트너 설정 꽝 메시지 (`guidanceMessage`, 기본: "다음 기회에!") |
| CTA 버튼 (코인 보유 시) | [다시 도전] → 즉시 재플레이 (코인 차감 확인 모달 생략) |
| CTA 버튼 (코인 미보유 시) | [코인 충전하기] → 코인 충전 페이지 이동 |
| 보조 버튼 | [돌아가기] → 매장 페이지 복귀 |


---


## 4.6: 게임 상태 전이


### 4.6.1: 상태 정의

| 상태 | 코드 | 설명 |
|------|------|------|
| 활성 | `ACTIVE` | 소비자 게임 참여 가능 |
| 비활성 | `INACTIVE` | 리워드 기능 비활성화로 게임 전체 비활성화 |
| 일시정지 | `PAUSED` | 모든 리워드 소진으로 자동 일시정지 |
| 미생성 | `NONE` | 게임 미생성 상태 (DB에 레코드 없음) |


### 4.6.2: 상태 전이 조건

```
NONE → ACTIVE
  조건: 게임 생성 완료 (유형 선택 + 리워드 2개 이상 적용 + 확률 100%)
  트리거: POST /api/v1/partner/game

ACTIVE → PAUSED
  조건: 총 잔여 수량 = 0 (모든 리워드 소진)
  트리거: 게임 참여 처리 시 서버 자동 감지
  동작: 파트너 알림 발송 + 소비자 "준비 중" 오버레이

PAUSED → ACTIVE
  조건: 리워드 보충 완료 (총 잔여 수량 > 0)
  트리거: POST /api/v1/partner/game/{gameId}/rewards/replenish
  동작: 오버레이 해제만 처리, 소비자 푸시·메시지 없음

ACTIVE → INACTIVE
  조건: 리워드 기능 비활성화 (7-2-8-3 > 3.1.1.1.)
  트리거: 리워드 활성화 토글 OFF
  동작: 게임 전체 비활성화 (개별 분리 불가)

INACTIVE → ACTIVE
  조건: 리워드 기능 재활성화 + 유효 리워드 존재
  트리거: 리워드 활성화 토글 ON

ACTIVE → NONE
  조건: 파트너 게임 삭제
  트리거: DELETE /api/v1/partner/game/{gameId}
  동작: 적용 리워드 복사본 삭제, 프리셋·라이브러리 유지
```


### 4.6.3: 소비자 표시 규칙

| 게임 상태 | 소비자 UI | 게임 버튼 | 코인 차감 |
|-----------|----------|----------|----------|
| `ACTIVE` | 정상 게임 화면 | [게임하기] 활성 | 차감 |
| `PAUSED` | "준비 중" 오버레이 | 비활성화 | 차감 안 됨 |
| `INACTIVE` | 게임 섹션 미표시 | — | — |
| `NONE` | 게임 섹션 미표시 | — | — |


---


## 4.7: 수량 관리 및 알림


### 4.7.1: 게임 참여 시 수량 감소

```
function processPlay(gameId, result):
    if result.type == "WIN":
        reward = getActiveReward(result.activeRewardId)
        reward.remainingQuantity -= 1
        
        if reward.remainingQuantity == 0:
            // 개별 리워드 소진 → 당첨 후보 제외 (다음 참여부터 적용)
            reward.status = "DEPLETED"
            logEvent("REWARD_DEPLETED", reward.activeRewardId)
    
    // 총 잔여 수량 재계산
    game = getGame(gameId)
    game.remainingQuantity = sum(r.remainingQuantity for r in game.activeRewards)
    game.remainingPercent = (game.remainingQuantity / game.totalQuantity) * 100
    
    checkDepletionThresholds(game)
```


### 4.7.2: 소진 감시 및 알림 트리거

```
function checkDepletionThresholds(game):
    // 10% 경고 (한 번만 발송)
    if game.remainingPercent <= 10 and !game.warningNotified:
        sendPartnerNotification(
            type: "GAME_REWARD_LOW",
            message: "게임 리워드 잔여 수량이 10% 이하입니다 (남은 {remaining}개/총 {total}개)",
            data: { gameId, remaining: game.remainingQuantity, total: game.totalQuantity }
        )
        game.warningNotified = true
    
    // 완전 소진 → 자동 일시정지
    if game.remainingQuantity == 0:
        triggerGamePause(game)
```


### 4.7.3: 자동 일시정지 처리

```
function triggerGamePause(game):
    game.status = "PAUSED"
    game.pausedAt = now()
    game.pauseReason = "ALL_REWARDS_DEPLETED"
    
    sendPartnerNotification(
        type: "GAME_PAUSED",
        message: "모든 리워드가 소진되어 게임이 일시정지되었습니다",
        data: { gameId: game.gameId },
        action: { label: "리워드 보충", deepLink: "/partner/game/settings#replenish" }
    )
    
    // 소비자 측 즉시 반영
    // - 게임 정보 조회 API에서 status: "PAUSED" 반환
    // - 게임 참여 API 호출 시 GAME_PAUSED 에러 반환
```


---


## 4.8: 에러 처리


### 4.8.1: 소비자 게임 에러 코드

| 코드 | HTTP | 설명 | 소비자 메시지 |
|------|------|------|-------------|
| `CGAME_001` | 404 | 게임 없음 (미생성 또는 삭제) | "이 매장에서는 게임을 운영하지 않고 있어요" |
| `CGAME_002` | 409 | 게임 일시정지 (PAUSED) | "현재 리워드를 준비 중이에요. 잠시 후 다시 시도해 주세요" |
| `CGAME_003` | 402 | 코인 잔액 부족 | "폼 코인이 부족합니다. 코인을 충전해 주세요" |
| `CGAME_004` | 409 | 무료 기회 없음 또는 이미 사용 | "오늘 무료 게임 기회를 이미 사용했어요" |
| `CGAME_005` | 400 | 유효하지 않은 시작점 (사다리) | "시작점을 다시 선택해 주세요" |
| `CGAME_006` | 410 | 캠페인 종료 또는 미존재 | "이 캠페인은 종료되었어요" |
| `CGAME_007` | 400 | QR 코드 파싱 실패 | "QR 코드를 다시 스캔해 주세요" |
| `CGAME_008` | 500 | 결과 결정 실패 (서버 내부 오류) | "일시적인 오류가 발생했어요. 코인은 차감되지 않았습니다" |
| `CGAME_009` | 409 | 게임 비활성 (INACTIVE) | "이 매장에서는 게임을 운영하지 않고 있어요" |


### 4.8.2: 코인 차감 롤백 정책

| 상황 | 처리 |
|------|------|
| API 호출 전 검증 실패 (코인 부족, 게임 PAUSED 등) | 코인 미차감 |
| 코인 차감 후 결과 결정 실패 | 코인 자동 환불 + `CGAME_008` 응답 |
| 코인 차감 + 결과 결정 성공 + 쿠폰 발급 실패 | 결과는 유효, 쿠폰 비동기 재발급 시도 (최대 3회) |
| 네트워크 타임아웃 (클라이언트 미수신) | 서버 결과 유효, 클라이언트 재조회 시 결과 복원 |

**트랜잭션 순서**: 코인 차감 → 결과 결정 → 수량 감소 → 쿠폰 발급 (하나의 DB 트랜잭션)


### 4.8.3: 중복 참여 방지

```
function preventDuplicate(consumerId, gameId):
    // 멱등성 키: consumerId + gameId + timestamp(초 단위)
    idempotencyKey = hash(consumerId + gameId + currentSecond())
    
    if redis.exists(idempotencyKey):
        return cachedResult(idempotencyKey)  // 동일 결과 반환
    
    result = processPlay(gameId, consumerId)
    redis.set(idempotencyKey, result, TTL=5seconds)
    
    return result
```


### 4.8.4: 공통 에러

| 상황 | HTTP | 처리 |
|------|------|------|
| 인증 실패 (토큰 만료) | 401 | 로그인 페이지로 유도 |
| 서버 내부 오류 | 500 | "일시적인 오류가 발생했어요" + 재시도 안내 |
| 요청 빈도 초과 | 429 | "잠시 후 다시 시도해 주세요" (3초 후 재시도 허용) |


---


• 참조: 3. 게임 이용 방법, 7-2-7-1 > 1.2.2.2. 게임 메커니즘 상세, 7-2-7-1 > 1.6. 개발자 인터랙션 명세, 7-2-7-2. 코인 관리 > 2.6. 개발자 인터랙션 명세
